---
layout: post
title: "Don't make Promises"
description: ""
category: post
---

I've come to a conclusion that some may disagree with. That Promises, just aren't worth 
the trouble.

Of course by Promises, I mean JavaScript Promises. If you don't know what Promises are, 
you should read some of the many articles on it. Most of the articles that you will find
will probably be gushing about Promises like it's the Second Coming. And given that the 
problem that it's trying to solve is called "Callback _Hell_" it's not that surprising.

So here is the use case that Promises try to solve. Let's say that you have two or more 
asynchronous operations to do (probably AJAX calls). But you need to use the value 
generated by the first operation in the second, and the value from the second in the 
third, and so on. Most JavaScript Developers would (initialy) solve this using just 
nested callbacks like this.

``` JavaScript
op1(function(result1) {
  op2(result1,function(result2) {
    op3(result2, function(result3) {
      // and on and on and on...
    });
  });
});
```

It's ugly, hard to read, and it's called _Callback Hell_. However if each of our op 
functions returned a Promise we could instead write the code like this.

``` JavaScript
op1().then(function(result) {
  return op2(result);
}).then(function(result) {
  return op3(result);
})// .then... keep chaining until you are done.
```

Which is obviously much nicer to look at. So you might be wondering why not use Promises? 
Because there is a much better option out there.

Before I discuss __"The Better Option"__ we should consider what Promises actually do for 
us. What we get from Promises is a form of control flow that is easier to read that a 
mess of callbacks. But the control flow Promises provide is very limited. You can only 
have "waterfall" flow (where the result from the first calls flows to the second, and the
second to the third, etc.). It won't help you paralelize syncronus calls, or allow you to
aggregate the results of all calls (unless you code each function to pass the result 
along). And if you need to chain together an arbitrary number of calls at runtime you 
could loose the greatest promise of Promises, readability.

So what is the __"The Better Option"__? Its [async](https://github.com/caolan/async). The
async library provides a whole host of functions for control flow. I wont rehash the 
entire api here, but it includes parallel, series, and waterfall. All of the control flow
functions also use more or less the same api. They take a list of functions (an array or 
object), and a single callback function that gets the aggregated (or final depending on 
the type of flow) result.
